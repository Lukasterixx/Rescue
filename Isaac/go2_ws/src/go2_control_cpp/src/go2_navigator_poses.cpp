#include <vector>
#include <string>
#include <set>
#include <memory>
#include <limits>
#include <cmath>
#include "go2_control_navigator/go2_navigator_poses.hpp"
#include <pluginlib/class_list_macros.hpp>

namespace go2_control_navigator
{

bool
NavigateThroughPosesNavigator::configure(
  rclcpp_lifecycle::LifecycleNode::WeakPtr parent_node,
  std::shared_ptr<nav2_util::OdomSmoother> odom_smoother)
{
  start_time_ = rclcpp::Time(0);
  auto node = parent_node.lock();

  if (!node->has_parameter("goals_blackboard_id")) {
    node->declare_parameter("goals_blackboard_id", std::string("goals"));
  }
  goals_blackboard_id_ = node->get_parameter("goals_blackboard_id").as_string();

  if (!node->has_parameter("path_blackboard_id")) {
    node->declare_parameter("path_blackboard_id", std::string("path"));
  }
  path_blackboard_id_ = node->get_parameter("path_blackboard_id").as_string();

  odom_smoother_ = odom_smoother;

  // Params for threshold and window size
  node->declare_parameter("pose_reached_threshold", 1.0);
  node->get_parameter("pose_reached_threshold", pose_reached_threshold_);
  
  node->declare_parameter("goal_window_size", 5);
  node->get_parameter("goal_window_size", goal_window_size_);

  waypoints_pub_ = node->create_publisher<geometry_msgs::msg::PoseArray>(
      "/waypoints_farm", rclcpp::QoS{10}.transient_local());

  return true;
}

std::string NavigateThroughPosesNavigator::getDefaultBTFilepath(
  rclcpp_lifecycle::LifecycleNode::WeakPtr parent_node)
{
  auto node = parent_node.lock();
  std::string xml;
  auto pkg_share = ament_index_cpp::get_package_share_directory("go2_control_cpp");

  if (!node->has_parameter("bt_tree_poses")) {
    node->declare_parameter<std::string>("bt_tree_poses", pkg_share + "/minimal_nav_tree.xml");
  }
  node->get_parameter("bt_tree_poses", xml);
  return pkg_share + "/" + xml;
}

bool
NavigateThroughPosesNavigator::goalReceived(ActionT::Goal::ConstSharedPtr goal)
{
  RCLCPP_INFO(logger_, "Go2Navigator::goalReceived() called with %zu poses", goal->poses.size());
  
  auto bt_file = goal->behavior_tree.empty()
    ? bt_action_server_->getDefaultBTFilename()
    : goal->behavior_tree;

  if (!bt_action_server_->loadBehaviorTree(bt_file)) {
    RCLCPP_ERROR(logger_, "BT file not found: %s", bt_file.c_str());
    return false;
  }
  
  initializeGoalPoses(goal);
  return true;
}

void
NavigateThroughPosesNavigator::goalCompleted(
  typename ActionT::Result::SharedPtr /*result*/,
  const nav2_behavior_tree::BtStatus /*final_bt_status*/)
{
}

void
NavigateThroughPosesNavigator::onLoop()
{
  using namespace nav2_util::geometry_utils; 

  auto feedback_msg = std::make_shared<ActionT::Feedback>();

  // --- SLIDING WINDOW UPDATE ---
  // Check progress against master list and get the next batch (window)
  auto current_window = updateGoalWindow();

  // If no goals remain in the window, we are done (or waiting for last execution)
  if (current_window.empty()) {
     // Even if empty, we let the BT run to completion (it will return success naturally)
     // But we update feedback
  }

  // --- FEEDBACK GENERATION ---
  geometry_msgs::msg::PoseStamped current_pose;
  nav2_util::getCurrentPose(
    current_pose, *feedback_utils_.tf,
    feedback_utils_.global_frame, feedback_utils_.robot_frame,
    feedback_utils_.transform_tolerance);

  try {
    // Current path from blackboard (generated by Planner for the *current window*)
    nav_msgs::msg::Path current_path;
    auto blackboard = bt_action_server_->getBlackboard();
    if (blackboard->get<nav_msgs::msg::Path>(path_blackboard_id_, current_path)) {
        // Simple distance to next immediate point in the window
        // (Approximate "distance remaining" logic)
        double distance_remaining = 0.0;
        if (!current_window.empty()) {
             distance_remaining = std::hypot(
                current_pose.pose.position.x - current_window.back().pose.position.x,
                current_pose.pose.position.y - current_window.back().pose.position.y
             );
        }
        feedback_msg->distance_remaining = distance_remaining;
    }
  } catch (...) {}

  int recovery_count = 0;
  bt_action_server_->getBlackboard()->get<int>("number_recoveries", recovery_count);
  
  feedback_msg->number_of_recoveries = recovery_count;
  feedback_msg->current_pose = current_pose;
  feedback_msg->navigation_time = clock_->now() - start_time_;
  
  // Return total remaining including those outside current window
  size_t total_remaining = all_poses_.size() - current_goal_index_;
  feedback_msg->number_of_poses_remaining = total_remaining;

  bt_action_server_->publishFeedback(feedback_msg);
}

void NavigateThroughPosesNavigator::onPreempt(ActionT::Goal::ConstSharedPtr goal)
{
  RCLCPP_INFO(logger_, "Received goal preemption request");

  if (goal->poses.empty()) {
    RCLCPP_INFO(logger_, "Received EMPTY goal (Cancellation). Clearing state.");
    bt_action_server_->acceptPendingGoal();
    
    // Clear everything
    Goals empty_goals;
    auto blackboard = bt_action_server_->getBlackboard();
    blackboard->set<Goals>(goals_blackboard_id_, empty_goals);
    
    // Clear Viz
    geometry_msgs::msg::PoseArray empty_msg;
    empty_msg.header.stamp = clock_->now();
    empty_msg.header.frame_id = "map"; 
    waypoints_pub_->publish(empty_msg);
    return;
  }

  // Accept new goal if BT is compatible
  if (goal->behavior_tree == bt_action_server_->getCurrentBTFilename() ||
      (goal->behavior_tree.empty() &&
       bt_action_server_->getCurrentBTFilename() == bt_action_server_->getDefaultBTFilename()))
  {
    RCLCPP_INFO(logger_, "Preempted: Accepting new goal list.");
    bt_action_server_->acceptPendingGoal();
    initializeGoalPoses(goal); // This resets the window and index
  } else {
    RCLCPP_WARN(logger_, "Preempt rejected (different BT). Terminating pending.");
    bt_action_server_->terminatePendingGoal();
  }
}

// ---------------------------------------------------------------------
//  SLIDING WINDOW LOGIC + 2D DISTANCE FIX + FRAME FIX
// ---------------------------------------------------------------------
std::vector<geometry_msgs::msg::PoseStamped>
NavigateThroughPosesNavigator::updateGoalWindow()
{
  auto blackboard = bt_action_server_->getBlackboard();

  // 1. Get Robot Pose
  geometry_msgs::msg::PoseStamped current_pose;
  if (!nav2_util::getCurrentPose(
    current_pose, *feedback_utils_.tf,
    feedback_utils_.global_frame, feedback_utils_.robot_frame,
    feedback_utils_.transform_tolerance)) 
  {
      // If we can't get pose, just return what is currently on the blackboard
      Goals existing;
      blackboard->get<Goals>(goals_blackboard_id_, existing);
      return existing;
  }

  bool window_updated = false;
  
  // 2. Check if we have reached the *next immediate target* in the master list
  //    We loop in case we moved fast and skipped multiple (though unlikely with windowing)
  while (current_goal_index_ < all_poses_.size()) {
    
    auto& target_wp = all_poses_[current_goal_index_];
    
    // -- Transform target to map frame --
    geometry_msgs::msg::PoseStamped wp_in_map;
    try {
        // [FIX] Don't overwrite frame_id. Use timestamp 0 for latest transform.
        auto wp_copy = target_wp;
        wp_copy.header.stamp = rclcpp::Time(0);
        
        wp_in_map = feedback_utils_.tf->transform(
            wp_copy, feedback_utils_.global_frame,
            tf2::durationFromSec(feedback_utils_.transform_tolerance));
    } catch (const tf2::TransformException & ex) {
        RCLCPP_WARN_THROTTLE(logger_, *clock_, 2000, "TF Error checking waypoint: %s", ex.what());
        break; // Can't verify distance, stop checking
    }

    // -- [FIX] 2D Distance Check --
    double dx = current_pose.pose.position.x - wp_in_map.pose.position.x;
    double dy = current_pose.pose.position.y - wp_in_map.pose.position.y;
    double dist_2d = std::hypot(dx, dy);

    if (dist_2d < pose_reached_threshold_) {
        RCLCPP_INFO(logger_, ">>> Waypoint %zu Reached (Dist: %.2fm)", current_goal_index_, dist_2d);
        current_goal_index_++;
        window_updated = true;
    } else {
        // If we haven't reached this one, we certainly haven't reached the ones after it
        // (assuming sequential navigation)
        break; 
    }
  }

  // 3. Construct the Window
  //    If we updated the index, OR if this is the first run, we construct the window.
  //    Actually, we should always reconstruct it to ensure the blackboard is in sync 
  //    (or at least check if we need to shift).
  
  std::vector<geometry_msgs::msg::PoseStamped> window_poses;
  size_t end_index = std::min(current_goal_index_ + goal_window_size_, all_poses_.size());
  
  for (size_t i = current_goal_index_; i < end_index; ++i) {
      window_poses.push_back(all_poses_[i]);
  }

  // 4. Update Blackboard
  blackboard->set<Goals>(goals_blackboard_id_, window_poses);

  // 5. Visualization (Publish only the active window)
  if (window_updated || window_poses.empty()) {
      geometry_msgs::msg::PoseArray pose_array_msg;
      pose_array_msg.header.stamp = clock_->now();
      if (!window_poses.empty()) {
          pose_array_msg.header.frame_id = window_poses[0].header.frame_id;
      } else {
          pose_array_msg.header.frame_id = feedback_utils_.global_frame;
      }
      
      for (const auto& wp : window_poses) {
          pose_array_msg.poses.push_back(wp.pose);
      }
      waypoints_pub_->publish(pose_array_msg);
  }

  return window_poses;
}


void
NavigateThroughPosesNavigator::initializeGoalPoses(ActionT::Goal::ConstSharedPtr goal)
{
  // 1. Store the full Master List
  all_poses_ = goal->poses;
  
  // 2. Reset Index
  current_goal_index_ = 0;
  start_time_ = clock_->now();

  RCLCPP_INFO(logger_, "Received %zu goals. Initializing window size %d.", all_poses_.size(), goal_window_size_);

  // 3. Reset Recoveries
  auto blackboard = bt_action_server_->getBlackboard();
  blackboard->set<int>("number_recoveries", 0);

  // 4. Force an immediate update of the window so the Blackboard is populated 
  //    before the Behavior Tree starts ticking.
  updateGoalWindow(); 
}

} 

PLUGINLIB_EXPORT_CLASS(
  go2_control_navigator::NavigateThroughPosesNavigator,
  backported_bt_navigator::NavigatorBase)